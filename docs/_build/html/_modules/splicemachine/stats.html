

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>splicemachine.stats &mdash; Splice MLManager  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/tabs.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.js"></script>
        <script src="../../_static/sphinx_tabs/tabs.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Splice MLManager
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../splicemachine.html">Splicemachine package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Splice MLManager</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>splicemachine.stats</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for splicemachine.stats</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">ThreadPool</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">import</span> <span class="nn">graphviz</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="kn">import</span> <span class="nn">pyspark_dist_explore</span> <span class="k">as</span> <span class="nn">dist_explore</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">F</span><span class="p">,</span> <span class="n">Row</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="n">DoubleType</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">,</span> <span class="n">IntegerType</span><span class="p">,</span> <span class="n">StringType</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.param.shared</span> <span class="kn">import</span> <span class="n">HasInputCol</span><span class="p">,</span> <span class="n">HasOutputCol</span><span class="p">,</span> <span class="n">Param</span>
<span class="kn">from</span> <span class="nn">pyspark.ml</span> <span class="kn">import</span> <span class="n">Pipeline</span><span class="p">,</span> <span class="n">Transformer</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.classification</span> <span class="kn">import</span> <span class="n">LogisticRegressionModel</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.util</span> <span class="kn">import</span> <span class="n">DefaultParamsReadable</span><span class="p">,</span> <span class="n">DefaultParamsWritable</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.feature</span> <span class="kn">import</span> <span class="n">StringIndexer</span><span class="p">,</span> <span class="n">OneHotEncoder</span><span class="p">,</span> <span class="n">VectorAssembler</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">Bucketizer</span><span class="p">,</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.evaluation</span> <span class="kn">import</span> <span class="n">RegressionEvaluator</span><span class="p">,</span> <span class="n">MulticlassClassificationEvaluator</span><span class="p">,</span> <span class="n">BinaryClassificationEvaluator</span>
<span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">keyword_only</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.tuning</span> <span class="kn">import</span> <span class="n">CrossValidator</span><span class="p">,</span> <span class="n">ParamGridBuilder</span><span class="p">,</span> <span class="n">CrossValidatorModel</span>


<div class="viewcode-block" id="get_confusion_matrix"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.get_confusion_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_confusion_matrix</span><span class="p">(</span><span class="n">spark</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">TN</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> <span class="n">FN</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates and returns a confusion matrix</span>

<span class="sd">    :param TP: True Positives</span>
<span class="sd">    :param TN: True Negatives</span>
<span class="sd">    :param FP: False Positives</span>
<span class="sd">    :param FN: False Negatives</span>

<span class="sd">    :return: Spark DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span><span class="p">)</span>
    <span class="n">confusion_matrix</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">_wrapped</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">([</span><span class="n">row</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">FN</span><span class="p">),</span>
                                                       <span class="n">row</span><span class="p">(</span><span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> <span class="n">TN</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">confusion_matrix</span></div>


<div class="viewcode-block" id="SpliceBaseEvaluator"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBaseEvaluator">[docs]</a><span class="k">class</span> <span class="nc">SpliceBaseEvaluator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base ModelEvaluator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">supported_metrics</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span>
                 <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for SpliceBaseEvaluator</span>
<span class="sd">        </span>
<span class="sd">        :param spark: spark session</span>
<span class="sd">        :param evaluator: evaluator class from spark</span>
<span class="sd">        :param supported_metrics: supported metrics list</span>
<span class="sd">        :param predictionCol: prediction column</span>
<span class="sd">        :param labelCol: label column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spark</span> <span class="o">=</span> <span class="n">spark</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span> <span class="o">=</span> <span class="n">evaluator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span> <span class="o">=</span> <span class="n">predictionCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">labelCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supported_metrics</span> <span class="o">=</span> <span class="n">supported_metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<div class="viewcode-block" id="SpliceBaseEvaluator.input"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBaseEvaluator.input">[docs]</a>    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictions_dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input a dataframe</span>
<span class="sd">        </span>
<span class="sd">        :param ev: evaluator class</span>
<span class="sd">        :param predictions_dataframe: input df</span>
<span class="sd">        :return: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_metrics</span><span class="p">:</span>
            <span class="n">evaluator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span>
                <span class="n">labelCol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">,</span> <span class="n">metricName</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evaluator</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">predictions_dataframe</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current </span><span class="si">{metric}</span><span class="s2">: </span><span class="si">{metric_val}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                                          <span class="n">metric_val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">avgs</span>
                                                          <span class="p">[</span><span class="n">metric</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="SpliceBaseEvaluator.get_results"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBaseEvaluator.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get Results</span>
<span class="sd">        </span>
<span class="sd">        :param dict: whether to get results in a dict or not</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">computed_avgs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">:</span>
            <span class="n">computed_avgs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">computed_avgs</span>

        <span class="n">metrics_row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">supported_metrics</span><span class="p">)</span>
        <span class="n">computed_row</span> <span class="o">=</span> <span class="n">metrics_row</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">computed_avgs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_metrics</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">_wrapped</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">([</span><span class="n">computed_row</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="SpliceBinaryClassificationEvaluator"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBinaryClassificationEvaluator">[docs]</a><span class="k">class</span> <span class="nc">SpliceBinaryClassificationEvaluator</span><span class="p">(</span><span class="n">SpliceBaseEvaluator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Splice Machine evaluator for Spark Binary Classification models. Implements functions from SpliceBaseEvaluator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_tp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_tn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_fn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_fp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">confusion_matrix</span> <span class="o">=</span> <span class="n">confusion_matrix</span>

        <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;areaUnderROC&quot;</span><span class="p">,</span> <span class="s2">&quot;areaUnderPR&quot;</span><span class="p">,</span> <span class="s1">&#39;TPR&#39;</span><span class="p">,</span> <span class="s1">&#39;SPC&#39;</span><span class="p">,</span> <span class="s1">&#39;PPV&#39;</span><span class="p">,</span> <span class="s1">&#39;NPV&#39;</span><span class="p">,</span> <span class="s1">&#39;FPR&#39;</span><span class="p">,</span> <span class="s1">&#39;FDR&#39;</span><span class="p">,</span> <span class="s1">&#39;FNR&#39;</span><span class="p">,</span> <span class="s1">&#39;ACC&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;MCC&#39;</span><span class="p">]</span>
        <span class="n">SpliceBaseEvaluator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">BinaryClassificationEvaluator</span><span class="p">,</span> <span class="n">supported</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="n">predictionCol</span><span class="p">,</span>
                                     <span class="n">labelCol</span><span class="o">=</span><span class="n">labelCol</span><span class="p">)</span>

<div class="viewcode-block" id="SpliceBinaryClassificationEvaluator.input"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBinaryClassificationEvaluator.input">[docs]</a>    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictions_dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate actual vs Predicted in a dataframe</span>
<span class="sd">        </span>
<span class="sd">        :param predictions_dataframe: the dataframe containing the label and the predicition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_metrics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;areaUnderROC&#39;</span><span class="p">,</span> <span class="s1">&#39;areaUnderPR&#39;</span><span class="p">]:</span>
                <span class="n">evaluator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">labelCol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">rawPredictionCol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">,</span> <span class="n">metricName</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evaluator</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">predictions_dataframe</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current </span><span class="si">{metric}</span><span class="s2">: </span><span class="si">{metric_val}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                                              <span class="n">metric_val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">avgs</span>
                                                              <span class="p">[</span><span class="n">metric</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">pred_v_lab</span> <span class="o">=</span> <span class="n">predictions_dataframe</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">)</span>  <span class="c1"># Select the actual and the predicted labels</span>

        <span class="c1"># Add confusion stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_tp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                                      <span class="o">&amp;</span> <span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_tn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                                      <span class="o">&amp;</span> <span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_fp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                                      <span class="o">&amp;</span> <span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_fn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                                      <span class="o">&amp;</span> <span class="p">(</span><span class="n">pred_v_lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prediction_col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>

        <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_tp</span><span class="p">)</span>
        <span class="n">TN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_tn</span><span class="p">)</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_fp</span><span class="p">)</span>
        <span class="n">FN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_fn</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;TPR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;SPC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;TNR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FP</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;PPV&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;NPV&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;FNR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">FN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FN</span> <span class="o">+</span> <span class="n">TP</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;FPR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FP</span> <span class="o">+</span> <span class="n">TN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;FDR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FP</span> <span class="o">+</span> <span class="n">TP</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;FOR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">FN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FN</span> <span class="o">+</span> <span class="n">TN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;ACC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">TN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span> <span class="o">+</span> <span class="n">FP</span> <span class="o">+</span> <span class="n">TN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;F1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">TP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="s1">&#39;MCC&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">TP</span> <span class="o">*</span> <span class="n">TN</span> <span class="o">-</span> <span class="n">FP</span> <span class="o">*</span> <span class="n">FN</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">confusion_matrix</span><span class="p">:</span>
            <span class="n">get_confusion_matrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="p">,</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">TP</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">TN</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">FN</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpliceBinaryClassificationEvaluator.plotROC"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceBinaryClassificationEvaluator.plotROC">[docs]</a>    <span class="k">def</span> <span class="nf">plotROC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fittedEstimator</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the receiver operating characteristic curve for the trained classifier</span>
<span class="sd">        </span>
<span class="sd">        :param fittedEstimator: fitted logistic regression model</span>
<span class="sd">        :param ax: matplotlib axis object</span>
<span class="sd">        :return: axis with ROC plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fittedEstimator</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">LogisticRegressionModel</span><span class="p">:</span>
            <span class="n">trainingSummary</span> <span class="o">=</span> <span class="n">fittedEstimator</span><span class="o">.</span><span class="n">summary</span>
            <span class="n">roc</span> <span class="o">=</span> <span class="n">trainingSummary</span><span class="o">.</span><span class="n">roc</span><span class="o">.</span><span class="n">toPandas</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">roc</span><span class="p">[</span><span class="s1">&#39;FPR&#39;</span><span class="p">],</span> <span class="n">roc</span><span class="p">[</span><span class="s1">&#39;TPR&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Training set areaUnderROC: </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trainingSummary</span><span class="o">.</span><span class="n">areaUnderROC</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;False Positive Rate&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;True Positive Rate&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;ROC Curve&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only supported for Logistic Regression Models&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SpliceRegressionEvaluator"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceRegressionEvaluator">[docs]</a><span class="k">class</span> <span class="nc">SpliceRegressionEvaluator</span><span class="p">(</span><span class="n">SpliceBaseEvaluator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Splice Machine evaluator for Spark Regression models. Implements functions from SpliceBaseEvaluator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">):</span>
        <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">,</span> <span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="s1">&#39;r2&#39;</span><span class="p">,</span> <span class="s1">&#39;mae&#39;</span><span class="p">]</span>
        <span class="n">SpliceBaseEvaluator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">RegressionEvaluator</span><span class="p">,</span> <span class="n">supported</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="n">predictionCol</span><span class="p">,</span>
                                     <span class="n">labelCol</span><span class="o">=</span><span class="n">labelCol</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpliceMultiClassificationEvaluator"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.SpliceMultiClassificationEvaluator">[docs]</a><span class="k">class</span> <span class="nc">SpliceMultiClassificationEvaluator</span><span class="p">(</span><span class="n">SpliceBaseEvaluator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Splice Machine evaluator for Spark MultiClass models. Implements functions from SpliceBaseEvaluator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">):</span>
        <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;f1&quot;</span><span class="p">,</span> <span class="s2">&quot;weightedPrecision&quot;</span><span class="p">,</span> <span class="s2">&quot;weightedRecall&quot;</span><span class="p">,</span> <span class="s2">&quot;accuracy&quot;</span><span class="p">]</span>
        <span class="n">SpliceBaseEvaluator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">MulticlassClassificationEvaluator</span><span class="p">,</span> <span class="n">supported</span><span class="p">,</span>
                                     <span class="n">predictionCol</span><span class="o">=</span><span class="n">predictionCol</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="n">labelCol</span><span class="p">)</span></div>


<div class="viewcode-block" id="DecisionTreeVisualizer"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer">[docs]</a><span class="k">class</span> <span class="nc">DecisionTreeVisualizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize a decision tree, either in code like format, or graphviz</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DecisionTreeVisualizer.feature_importance"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.feature_importance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">feature_importance</span><span class="p">(</span><span class="n">spark</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">featuresCol</span><span class="o">=</span><span class="s2">&quot;features&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dataframe containing the relative importance of each feature</span>
<span class="sd">        </span>
<span class="sd">        :param model: The Spark Machine Learning model</span>
<span class="sd">        :param dataframe: Spark Dataframe</span>
<span class="sd">        :param featureCol: (str) the column containing the feature vector</span>
<span class="sd">        :return: dataframe containing importance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">featureImp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">featureImportances</span>
        <span class="n">list_extract</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">featuresCol</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ml_attr&quot;</span><span class="p">][</span><span class="s2">&quot;attrs&quot;</span><span class="p">]:</span>
            <span class="n">list_extract</span> <span class="o">=</span> <span class="n">list_extract</span> <span class="o">+</span> <span class="n">dataset</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">featuresCol</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ml_attr&quot;</span><span class="p">][</span><span class="s2">&quot;attrs&quot;</span><span class="p">][</span>
                <span class="n">i</span><span class="p">]</span>
        <span class="n">varlist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">list_extract</span><span class="p">)</span>
        <span class="n">varlist</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">varlist</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">featureImp</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">spark</span><span class="o">.</span><span class="n">_wrapped</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">((</span><span class="n">varlist</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DecisionTreeVisualizer.visualize"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.visualize">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">feature_column_names</span><span class="p">,</span>
            <span class="n">label_names</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">tree_name</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span>
            <span class="n">visual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize a decision tree, either in a code like format, or graphviz</span>
<span class="sd">        </span>
<span class="sd">        :param model: the fitted decision tree classifier\n</span>
<span class="sd">        :param feature_column_names: (List[str]) column names for features</span>
<span class="sd">            You can access these feature names by using your VectorAssembler (in PySpark) and calling it&#39;s .getInputCols() function</span>
<span class="sd">        :param label_names: (List[str]) labels vector (below avg, above avg)</span>
<span class="sd">        :param size: tuple(int,int) The size of the graph. If unspecified, graphviz will automatically assign a size</span>
<span class="sd">        :param horizontal: (Bool) if the tree should be rendered horizontally</span>
<span class="sd">        :param tree_name: the name you would like to call the tree</span>
<span class="sd">        :param visual: bool, true if you want a graphviz pdf containing your file</span>
<span class="sd">        :return dot: The graphvis object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tree_to_json</span> <span class="o">=</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">replacer</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">toDebugString</span><span class="p">,</span>
                                                       <span class="p">[</span><span class="s1">&#39;feature &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_column_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                                                       <span class="nb">reversed</span><span class="p">(</span><span class="n">feature_column_names</span><span class="p">))</span>

        <span class="n">tree_to_json</span> <span class="o">=</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">replacer</span><span class="p">(</span><span class="n">tree_to_json</span><span class="p">,</span>
                                                       <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Predict: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s1">.0&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                                                       <span class="nb">reversed</span><span class="p">(</span><span class="n">label_names</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visual</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree_to_json</span>

        <span class="n">dot</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="s1">&#39;Decision Tree&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">horizontal</span><span class="p">:</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;LR&quot;</span><span class="p">)</span>
        <span class="n">dot</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightblue2&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;filled&#39;</span><span class="p">)</span>
        <span class="n">json_d</span> <span class="o">=</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">tree_json</span><span class="p">(</span><span class="n">tree_to_json</span><span class="p">)</span>

        <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">json_d</span><span class="p">,</span>
                                        <span class="n">realroot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dot</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">tree_name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Generated pdf file of tree. You can view it in your Jupyter directory under </span><span class="si">{</span><span class="n">dot</span><span class="o">.</span><span class="n">filepath</span><span class="si">}</span><span class="s1">.pdf</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dot</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">dot</span><span class="p">)</span></div>

<div class="viewcode-block" id="DecisionTreeVisualizer.replacer"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.replacer">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">replacer</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="n">good</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace every string in &quot;bad&quot; with the corresponding string in &quot;good&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param string: string to replace in</span>
<span class="sd">        :param bad: array of strings to replace</span>
<span class="sd">        :param good: array of strings to replace with</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bad</span><span class="p">,</span> <span class="n">good</span><span class="p">):</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span></div>

<div class="viewcode-block" id="DecisionTreeVisualizer.add_node"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.add_node">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span>
            <span class="n">dot</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">node_hash</span><span class="p">,</span>
            <span class="n">root</span><span class="p">,</span>
            <span class="n">realroot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse through the .debugString json and generate a graphviz tree</span>
<span class="sd">        </span>
<span class="sd">        :param dot: dot file object</span>
<span class="sd">        :param parent: not used currently</span>
<span class="sd">        :param node_hash: unique node id</span>
<span class="sd">        :param root: the root of tree</span>
<span class="sd">        :param realroot: whether or not it is the real root, or a recursive root</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">node_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">realroot</span><span class="p">:</span>
                <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">node_hash</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">):</span>
                    <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                                    <span class="n">node_id</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                                    <span class="n">node_id</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                                    <span class="n">node_id</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="DecisionTreeVisualizer.parse"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.parse">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lines in debug string</span>
<span class="sd">       </span>
<span class="sd">        :param lines:</span>
<span class="sd">        :return: block json</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">block</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;If&#39;</span><span class="p">):</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span>
                                                                <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">bl</span><span class="p">,</span>
                              <span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lines</span><span class="p">)})</span>

                <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Else&#39;</span><span class="p">):</span>
                    <span class="n">be</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(&#39;</span>
                                                                    <span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">be</span><span class="p">,</span>
                                  <span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lines</span><span class="p">)})</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;If&#39;</span><span class="p">,</span> <span class="s1">&#39;Else&#39;</span><span class="p">)):</span>
                <span class="n">block2</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">block2</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">block</span></div>

<div class="viewcode-block" id="DecisionTreeVisualizer.tree_json"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.DecisionTreeVisualizer.tree_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tree_json</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a JSON representation of a decision tree</span>
<span class="sd">        </span>
<span class="sd">        :param tree: tree debug string</span>
<span class="sd">        :return: json</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Root&#39;</span><span class="p">,</span>
                <span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="n">DecisionTreeVisualizer</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:])}]</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="inspectTable"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.inspectTable">[docs]</a><span class="k">def</span> <span class="nf">inspectTable</span><span class="p">(</span><span class="n">spliceMLCtx</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">topN</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inspect the values of the columns of the table (dataframe) returned from the sql query</span>
<span class="sd">    </span>
<span class="sd">    :param spliceMLCtx: SpliceMLContext</span>
<span class="sd">    :param sql: sql string to execute</span>
<span class="sd">    :param topN: the number of most frequent elements of a column to return, defaults to 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">spliceMLCtx</span><span class="o">.</span><span class="n">df</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_type</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------Inspecting column </span><span class="si">{}</span><span class="s2"> -------- &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_col</span><span class="p">))</span>

        <span class="n">val_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">val_counts</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">val_counts</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">desc</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">topN</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;double&#39;</span> <span class="ow">or</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<span class="c1"># Custom Transformers</span>
<div class="viewcode-block" id="Rounder"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.Rounder">[docs]</a><span class="k">class</span> <span class="nc">Rounder</span><span class="p">(</span><span class="n">Transformer</span><span class="p">,</span> <span class="n">HasInputCol</span><span class="p">,</span> <span class="n">HasOutputCol</span><span class="p">,</span> <span class="n">DefaultParamsReadable</span><span class="p">,</span> <span class="n">DefaultParamsWritable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transformer to round predictions for ordinal regression</span>
<span class="sd">    Follows: https://spark.apache.org/docs/latest/ml-pipeline.html#transformers</span>
<span class="sd">    </span>
<span class="sd">    :param Transformer: Inherited Class</span>
<span class="sd">    :param HasInputCol: Inherited Class</span>
<span class="sd">    :param HasOutputCol: Inherited Class</span>
<span class="sd">    :return: Transformed Dataframe with rounded predictionCol</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; from pyspark.sql.session import SparkSession</span>
<span class="sd">            &gt;&gt;&gt; from splicemachine.stats.stats import Rounder</span>
<span class="sd">            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()</span>
<span class="sd">            &gt;&gt;&gt; dataset = spark.createDataFrame(</span>
<span class="sd">            ...      [(0.2, 0.0),</span>
<span class="sd">            ...       (1.2, 1.0),</span>
<span class="sd">            ...       (1.6, 2.0),</span>
<span class="sd">            ...       (1.1, 0.0),</span>
<span class="sd">            ...       (3.1, 0.0)],</span>
<span class="sd">            ...      [&quot;prediction&quot;, &quot;label&quot;])</span>
<span class="sd">            &gt;&gt;&gt; dataset.show()</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |prediction|label|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |       0.2|  0.0|</span>
<span class="sd">            |       1.2|  1.0|</span>
<span class="sd">            |       1.6|  2.0|</span>
<span class="sd">            |       1.1|  0.0|</span>
<span class="sd">            |       3.1|  0.0|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            &gt;&gt;&gt; rounder = Rounder(predictionCol = &quot;prediction&quot;, labelCol = &quot;label&quot;,</span>
<span class="sd">                clipPreds = True)</span>
<span class="sd">            &gt;&gt;&gt; rounder.transform(dataset).show()</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |prediction|label|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |       0.0|  0.0|</span>
<span class="sd">            |       1.0|  1.0|</span>
<span class="sd">            |       2.0|  2.0|</span>
<span class="sd">            |       1.0|  0.0|</span>
<span class="sd">            |       2.0|  0.0|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            &gt;&gt;&gt; rounderNoClip = Rounder(predictionCol = &quot;prediction&quot;, labelCol = &quot;label&quot;,</span>
<span class="sd">                clipPreds = False)</span>
<span class="sd">            &gt;&gt;&gt; rounderNoClip.transform(dataset).show()</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |prediction|label|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">            |       0.0|  0.0|</span>
<span class="sd">            |       1.0|  1.0|</span>
<span class="sd">            |       2.0|  2.0|</span>
<span class="sd">            |       1.0|  0.0|</span>
<span class="sd">            |       3.0|  0.0|</span>
<span class="sd">            +----------+-----+</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">clipPreds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialize self</span>

<span class="sd">        :param predictionCol: column containing predictions, defaults to &quot;prediction&quot;</span>
<span class="sd">        :param labelCol: column containing labels, defaults to &quot;label&quot;</span>
<span class="sd">        :param clipPreds: clip all predictions above a specified maximum value</span>
<span class="sd">        :param maxLabel: optional: the maximum value for the prediction column, otherwise uses the maximum of the labelCol, defaults to None</span>
<span class="sd">        :param minLabel: optional: the minimum value for the prediction column, otherwise uses the maximum of the labelCol, defaults to None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Rounder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span> <span class="o">=</span> <span class="n">labelCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictionCol</span> <span class="o">=</span> <span class="n">predictionCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clipPreds</span> <span class="o">=</span> <span class="n">clipPreds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxLabel</span> <span class="o">=</span> <span class="n">maxLabel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minLabel</span> <span class="o">=</span> <span class="n">minLabel</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predictionCol</span><span class="o">=</span><span class="s2">&quot;prediction&quot;</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rounds the predictions to the nearest integer value, and also clips them at the max/min value observed in label</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: dataframe with predictions to be rounded</span>
<span class="sd">        :return: DataFrame with rounded predictions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labelCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span>
        <span class="n">predictionCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictionCol</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipPreds</span><span class="p">:</span>
            <span class="n">max_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLabel</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLabel</span> <span class="k">else</span> <span class="n">dataset</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">labelCol</span><span class="p">:</span> <span class="s1">&#39;max&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">min_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLabel</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLabel</span> <span class="k">else</span> <span class="n">dataset</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">labelCol</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clip</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">max_label</span> <span class="k">else</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">min_label</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">min_label</span> <span class="k">else</span> <span class="n">x</span><span class="p">),</span>
                         <span class="n">DoubleType</span><span class="p">())</span>

            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">predictionCol</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">predictionCol</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">predictionCol</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">predictionCol</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="OneHotDummies"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.OneHotDummies">[docs]</a><span class="k">class</span> <span class="nc">OneHotDummies</span><span class="p">(</span><span class="n">Transformer</span><span class="p">,</span> <span class="n">HasInputCol</span><span class="p">,</span> <span class="n">HasOutputCol</span><span class="p">,</span> <span class="n">DefaultParamsReadable</span><span class="p">,</span> <span class="n">DefaultParamsWritable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transformer to generate dummy columns for categorical variables as a part of a preprocessing pipeline\n</span>
<span class="sd">    Follows: https://spark.apache.org/docs/latest/ml-pipeline.html#transformers</span>
<span class="sd">    </span>
<span class="sd">    :param Transformer: Inherited Classes</span>
<span class="sd">    :param HasInputCol: Inherited Classes</span>
<span class="sd">    :param HasOutputCol: Inherited Classes</span>
<span class="sd">    :return: pyspark DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns variables to parameters passed</span>

<span class="sd">        :param inputCol: Sparse vector returned by OneHotEncoders, defaults to None</span>
<span class="sd">        :param outputCol: string base to append to output columns names, defaults to None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OneHotDummies</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># kwargs = self._input_kwargs</span>
        <span class="c1"># self.setParams(**kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputCol</span> <span class="o">=</span> <span class="n">inputCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputCol</span> <span class="o">=</span> <span class="n">outputCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outcols</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates through the number of categorical values of a categorical variable and adds dummy columns for each of those categories</span>
<span class="sd">        For a string categorical column, include this transformer in the following workflow: StringIndexer -&gt; OneHotEncoder -&gt; OneHotDummies -&gt; PCA/ Learning Algorithm</span>

<span class="sd">        :param dataset: PySpark DataFrame where inputCol is the column  returned by by OneHotEncoders</span>
<span class="sd">        :return: original DataFrame with M additional columns where M = # of categories for this variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_col_suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputCol</span>  <span class="c1"># this is what I want to append to the column name</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputCol</span>

        <span class="n">out_col_base</span> <span class="o">=</span> <span class="n">col_name</span> <span class="o">+</span> <span class="n">out_col_suffix</span>  <span class="c1"># this is the base for the n outputted columns</span>

        <span class="c1"># helper functions</span>
        <span class="n">get_num_categories</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">IntegerType</span><span class="p">())</span>
        <span class="n">get_active_index</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">IntegerType</span><span class="p">())</span>
        <span class="n">check_active_index</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">active</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">active</span> <span class="o">==</span> <span class="n">i</span><span class="p">),</span> <span class="n">IntegerType</span><span class="p">())</span>

        <span class="n">num_categories</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">get_num_categories</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;num_categories&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>  <span class="c1"># this returns a dataframe</span>
        <span class="k">if</span> <span class="n">num_categories</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># making sure all the sparse vectors have the same number of categories</span>
            <span class="n">num_categories_int</span> <span class="o">=</span> <span class="n">num_categories</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;num_categories&#39;</span><span class="p">]</span>  <span class="c1"># now this is an int</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s1">&#39;active_index&#39;</span><span class="p">,</span> <span class="n">get_active_index</span><span class="p">(</span><span class="n">col_name</span><span class="p">))</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories_int</span><span class="p">):</span>  <span class="c1"># Now I&#39;m going to make a column for each category</span>
            <span class="n">column_name</span> <span class="o">=</span> <span class="n">out_col_base</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">check_active_index</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s1">&#39;active_index&#39;</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
            <span class="n">column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;active_index&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outcols</span> <span class="o">=</span> <span class="n">column_names</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">getOutCols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outcols</span></div>


<div class="viewcode-block" id="IndReconstructer"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.IndReconstructer">[docs]</a><span class="k">class</span> <span class="nc">IndReconstructer</span><span class="p">(</span><span class="n">Transformer</span><span class="p">,</span> <span class="n">HasInputCol</span><span class="p">,</span> <span class="n">HasOutputCol</span><span class="p">,</span> <span class="n">DefaultParamsReadable</span><span class="p">,</span> <span class="n">DefaultParamsWritable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transformer to reconstruct String Index from OneHotDummy Columns. This can be used as a part of a Pipeline Ojbect\n</span>
<span class="sd">    Follows: https://spark.apache.org/docs/latest/ml-pipeline.html#transformers</span>

<span class="sd">    :param Transformer: Inherited Class</span>
<span class="sd">    :param HasInputCol: Inherited Class</span>
<span class="sd">    :param HasOutputCol: Inherited Class</span>
<span class="sd">    :return: Transformed PySpark Dataframe With Original String Indexed Variables</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndReconstructer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># kwargs = self._input_kwargs</span>
        <span class="c1"># self.setParams(**kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputCol</span> <span class="o">=</span> <span class="n">inputCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputCol</span> <span class="o">=</span> <span class="n">outputCol</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates through the oneHotDummy columns for a categorical variable and returns the index of the column that is closest to one. This corresponds to the stringIndexed value of this feature for this row.</span>

<span class="sd">        :param dataset: dataset with OneHotDummy columns</span>
<span class="sd">        :return: DataFrame with column corresponding to a categorical indexed column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inColBase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputCol</span>
        <span class="n">outCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputCol</span>

        <span class="n">closestToOne</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DoubleType</span><span class="p">())</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">closestToOne</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">inColBase</span> <span class="ow">in</span> <span class="n">i</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span>
                                   <span class="n">inColBase</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;SUBJECT&#39;</span><span class="p">])</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="n">dummies</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s1">&#39;least_val&#39;</span><span class="p">,</span>
                                     <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">least</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">inColBase</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>

        <span class="n">dummies</span> <span class="o">=</span> <span class="n">dummies</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s1">&#39;least_val&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="s1">&#39;isind&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">inColBase</span> <span class="ow">in</span> <span class="n">i</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span>
              <span class="n">inColBase</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;SUBJECT&#39;</span><span class="p">])</span>
        <span class="n">getActive</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntegerType</span><span class="p">())</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="n">dummies</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">outCol</span><span class="p">,</span> <span class="n">getActive</span><span class="p">(</span>
            <span class="n">F</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dummies</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;SUBJECT&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;struct&#39;</span><span class="p">)))</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dummies</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="s1">&#39;SUBJECT&#39;</span><span class="p">,</span> <span class="n">outCol</span><span class="p">]),</span> <span class="s1">&#39;SUBJECT&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="OverSampler"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.OverSampler">[docs]</a><span class="k">class</span> <span class="nc">OverSampler</span><span class="p">(</span><span class="n">Transformer</span><span class="p">,</span> <span class="n">HasInputCol</span><span class="p">,</span> <span class="n">HasOutputCol</span><span class="p">,</span> <span class="n">DefaultParamsReadable</span><span class="p">,</span> <span class="n">DefaultParamsWritable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transformer to oversample datapoints with minority labels\n</span>
<span class="sd">    </span>
<span class="sd">    Follows: https://spark.apache.org/docs/latest/ml-pipeline.html#transformers</span>
<span class="sd">    </span>
<span class="sd">    :param Transformer: Inherited Class</span>
<span class="sd">    :param HasInputCol: Inherited Class</span>
<span class="sd">    :param HasOutputCol: Inherited Class</span>
<span class="sd">    :return: PySpark Dataframe with labels in approximately equal ratios</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; from pyspark.sql import functions as F</span>
<span class="sd">            &gt;&gt;&gt; from pyspark.sql.session import SparkSession</span>
<span class="sd">            &gt;&gt;&gt; from pyspark.stats.linalg import Vectors</span>
<span class="sd">            &gt;&gt;&gt; from splicemachine.stats.stats import OverSampler</span>
<span class="sd">            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()</span>
<span class="sd">            &gt;&gt;&gt; df = spark.createDataFrame(</span>
<span class="sd">            ...      [(Vectors.dense([0.0]), 0.0),</span>
<span class="sd">            ...       (Vectors.dense([0.5]), 0.0),</span>
<span class="sd">            ...       (Vectors.dense([0.4]), 1.0),</span>
<span class="sd">            ...       (Vectors.dense([0.6]), 1.0),</span>
<span class="sd">            ...       (Vectors.dense([1.0]), 1.0)] * 10,</span>
<span class="sd">            ...      [&quot;features&quot;, &quot;Class&quot;])</span>
<span class="sd">            &gt;&gt;&gt; df.groupBy(F.col(&quot;Class&quot;)).count().orderBy(&quot;count&quot;).show()</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">            |Class|count|</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">            |  0.0|   20|</span>
<span class="sd">            |  1.0|   30|</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">            &gt;&gt;&gt; oversampler = OverSampler(labelCol = &quot;Class&quot;, strategy = &quot;auto&quot;)</span>
<span class="sd">            &gt;&gt;&gt; oversampler.transform(df).groupBy(&quot;Class&quot;).count().show()</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">            |Class|count|</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">            |  0.0|   29|</span>
<span class="sd">            |  1.0|   30|</span>
<span class="sd">            +-----+-----+</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">randomState</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize self</span>

<span class="sd">        :param labelCol: Label Column name, defaults to None</span>
<span class="sd">        :param strategy: defaults to &quot;auto&quot;, strategy to resample the dataset:</span>
<span class="sd">                        • Only currently supported for &quot;auto&quot; Corresponds to random samples with repleaement</span>
<span class="sd">        :param randomState: sets the seed of sample algorithm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OverSampler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span> <span class="o">=</span> <span class="n">labelCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">withReplacement</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">randomState</span> <span class="k">else</span> <span class="n">randomState</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Oversamples</span>

<span class="sd">        :param dataset: dataframe to be oversampled</span>
<span class="sd">        :return: DataFrame with the resampled data points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>

            <span class="n">pd_value_counts</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">toPandas</span><span class="p">()</span>

            <span class="n">label_type</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="o">.</span><span class="n">simpleString</span><span class="p">()</span>
            <span class="n">types_dic</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">}</span>

            <span class="n">maxidx</span> <span class="o">=</span> <span class="n">pd_value_counts</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">majorityLabel</span> <span class="o">=</span> <span class="n">types_dic</span><span class="p">[</span><span class="n">label_type</span><span class="p">](</span><span class="n">pd_value_counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxidx</span><span class="p">])</span>
            <span class="n">majorityData</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majorityLabel</span><span class="p">)</span>

            <span class="n">returnData</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd_value_counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Error! Number of labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pd_value_counts</span><span class="p">)</span><span class="si">}</span><span class="s1">. Cannot Oversample with this number of classes&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd_value_counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">minidx</span> <span class="o">=</span> <span class="n">pd_value_counts</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
                <span class="n">minorityLabel</span> <span class="o">=</span> <span class="n">types_dic</span><span class="p">[</span><span class="n">label_type</span><span class="p">](</span><span class="n">pd_value_counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">minidx</span><span class="p">])</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">pd_value_counts</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxidx</span><span class="p">]</span> <span class="o">/</span> <span class="n">pd_value_counts</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">minidx</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>

                <span class="n">returnData</span> <span class="o">=</span> <span class="n">majorityData</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">)</span> <span class="o">==</span> <span class="n">minorityLabel</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">withReplacement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">withReplacement</span><span class="p">,</span>
                                                                                 <span class="n">fraction</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">randomState</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">minority_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd_value_counts</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">maxidx</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">])</span>

                <span class="n">ratios</span> <span class="o">=</span> <span class="p">{</span><span class="n">types_dic</span><span class="p">[</span><span class="n">label_type</span><span class="p">](</span><span class="n">minority_label</span><span class="p">):</span> <span class="n">pd_value_counts</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxidx</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="n">pd_value_counts</span><span class="p">[</span><span class="n">pd_value_counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">]</span> <span class="o">==</span> <span class="n">minority_label</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">minority_label</span> <span class="ow">in</span>
                          <span class="n">minority_labels</span><span class="p">}</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">minorityLabel</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ratios</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">minorityData</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelCol</span><span class="p">)</span> <span class="o">==</span> <span class="n">minorityLabel</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="n">withReplacement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">withReplacement</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">randomState</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">returnData</span><span class="p">:</span>
                        <span class="n">returnData</span> <span class="o">=</span> <span class="n">majorityData</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">minorityData</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">returnData</span> <span class="o">=</span> <span class="n">returnData</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">minorityData</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">returnData</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only auto is currently implemented&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="OverSampleCrossValidator"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.OverSampleCrossValidator">[docs]</a><span class="k">class</span> <span class="nc">OverSampleCrossValidator</span><span class="p">(</span><span class="n">CrossValidator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to perform Cross Validation model evaluation while over-sampling minority labels.</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        .. code-block:: python</span>
<span class="sd">            </span>
<span class="sd">            &gt;&gt;&gt; from pyspark.sql.session import SparkSession</span>
<span class="sd">            &gt;&gt;&gt; from pyspark.stats.classification import LogisticRegression</span>
<span class="sd">            &gt;&gt;&gt; from pyspark.stats.evaluation import BinaryClassificationEvaluator,\n</span>
<span class="sd">             MulticlassClassificationEvaluator</span>
<span class="sd">            &gt;&gt;&gt; from pyspark.stats.linalg import Vectors</span>
<span class="sd">            &gt;&gt;&gt; from splicemachine.stats.stats import OverSampleCrossValidator</span>
<span class="sd">            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()</span>
<span class="sd">            &gt;&gt;&gt; dataset = spark.createDataFrame(</span>
<span class="sd">            ...      [(Vectors.dense([0.0]), 0.0),</span>
<span class="sd">            ...       (Vectors.dense([0.5]), 0.0),</span>
<span class="sd">            ...       (Vectors.dense([0.4]), 1.0),</span>
<span class="sd">            ...       (Vectors.dense([0.6]), 1.0),</span>
<span class="sd">            ...       (Vectors.dense([1.0]), 1.0)] * 10,</span>
<span class="sd">            ...      [&quot;features&quot;, &quot;label&quot;])</span>
<span class="sd">            &gt;&gt;&gt; lr = LogisticRegression()</span>
<span class="sd">            &gt;&gt;&gt; grid = ParamGridBuilder().addGrid(lr.maxIter, [0, 1]).build()</span>
<span class="sd">            &gt;&gt;&gt; PRevaluator = BinaryClassificationEvaluator(metricName = &#39;areaUnderPR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; AUCevaluator = BinaryClassificationEvaluator(metricName = &#39;areaUnderROC&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ACCevaluator = MulticlassClassificationEvaluator(metricName=&quot;accuracy&quot;)</span>
<span class="sd">            &gt;&gt;&gt; cv = OverSampleCrossValidator(estimator=lr, estimatorParamMaps=grid,</span>
<span class="sd">                    evaluator=AUCevaluator, altEvaluators = [PRevaluator, ACCevaluator],</span>
<span class="sd">                    parallelism=2,seed = 1234)</span>
<span class="sd">            &gt;&gt;&gt; cvModel = cv.fit(dataset)</span>
<span class="sd">            &gt;&gt;&gt; print(cvModel.avgMetrics)</span>
<span class="sd">            [(0.5, [0.5888888888888888, 0.3888888888888889]), (0.806878306878307,</span>
<span class="sd">                [0.8556863149300125, 0.7055555555555556])]</span>
<span class="sd">            &gt;&gt;&gt; print(AUCevaluator.evaluate(cvModel.transform(dataset)))</span>
<span class="sd">            0.8333333333333333</span>
<span class="sd">            &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">estimatorParamMaps</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">numFolds</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallelism</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">collectSubModels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelCol</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">altEvaluators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overSample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Initialize Self</span>

<span class="sd">        :param estimator: Machine Learning Model, defaults to None</span>
<span class="sd">        :param estimatorParamMaps: paramMap to search, defaults to None</span>
<span class="sd">        :param evaluator: primary model evaluation metric, defaults to None</span>
<span class="sd">        :param numFolds: number of folds to perform, defaults to 3</span>
<span class="sd">        :param seed: random state, defaults to None</span>
<span class="sd">        :param parallelism: number of threads, defaults to 1</span>
<span class="sd">        :param collectSubModels: to return submodels, defaults to False</span>
<span class="sd">        :param labelCol: target variable column label, defaults to &#39;label&#39;</span>
<span class="sd">        :param altEvaluators: additional metrics to evaluate, defaults to None</span>
<span class="sd">                             If passed, the metrics of the alternate evaluators are accessed in the CrossValidatorModel.avgMetrics attribute</span>
<span class="sd">        :param overSample: Boolean: to perform oversampling of minority labels, defaults to True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">labelCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altEvaluators</span> <span class="o">=</span> <span class="n">altEvaluators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toOverSample</span> <span class="o">=</span> <span class="n">overSample</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OverSampleCrossValidator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">estimatorParamMaps</span><span class="o">=</span><span class="n">estimatorParamMaps</span><span class="p">,</span>
                                                       <span class="n">evaluator</span><span class="o">=</span><span class="n">evaluator</span><span class="p">,</span> <span class="n">numFolds</span><span class="o">=</span><span class="n">numFolds</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                                       <span class="n">parallelism</span><span class="o">=</span><span class="n">parallelism</span><span class="p">,</span> <span class="n">collectSubModels</span><span class="o">=</span><span class="n">collectSubModels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>

    <span class="k">def</span> <span class="nf">getOversample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toOverSample</span>

    <span class="k">def</span> <span class="nf">getAltEvaluators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">altEvaluators</span>

    <span class="k">def</span> <span class="nf">_parallelFitTasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">eva</span><span class="p">,</span> <span class="n">validation</span><span class="p">,</span> <span class="n">epm</span><span class="p">,</span> <span class="n">collectSubModel</span><span class="p">,</span> <span class="n">altEvaluators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a list of callables which can be called from different threads to fit and evaluate</span>
<span class="sd">        an estimator in parallel. Each callable returns an `(index, metric)` pair if altEvaluators, (index, metric, [alt_metrics]).</span>
<span class="sd">        </span>
<span class="sd">        :param est: Estimator, the estimator to be fit.</span>
<span class="sd">        :param train: DataFrame, training data set, used for fitting.</span>
<span class="sd">        :param eva: Evaluator, used to compute `metric`</span>
<span class="sd">        :param validation: DataFrame, validation data set, used for evaluation.</span>
<span class="sd">        :param epm: Sequence of ParamMap, params maps to be used during fitting &amp; evaluation.</span>
<span class="sd">        :param collectSubModel: Whether to collect sub model.</span>
<span class="sd">        :return: (int, float, subModel), an index into `epm` and the associated metric value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">modelIter</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">fitMultiple</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">epm</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">singleTask</span><span class="p">():</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">modelIter</span><span class="p">)</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">eva</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="n">epm</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
            <span class="n">altmetrics</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">altEvaluators</span><span class="p">:</span>
                <span class="n">altmetrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">altEva</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="n">epm</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="k">for</span> <span class="n">altEva</span> <span class="ow">in</span> <span class="n">altEvaluators</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">altmetrics</span><span class="p">,</span> <span class="n">model</span> <span class="k">if</span> <span class="n">collectSubModel</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">singleTask</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">epm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs k-fold crossvaldidation on simple oversampled dataset</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: full dataset</span>
<span class="sd">        :return: CrossValidatorModel containing the fitted BestModel with the average of the primary and alternate metrics in a list of tuples in the format: [(paramComb1_average_primary_metric, [paramComb1_average_altmetric1,paramComb1_average_altmetric2]), (paramComb2_average_primary_metric, [paramComb2_average_altmetric1,paramComb2_average_altmetric2])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOrDefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">)</span>
        <span class="n">epm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOrDefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimatorParamMaps</span><span class="p">)</span>
        <span class="n">numModels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">epm</span><span class="p">)</span>
        <span class="n">eva</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOrDefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluator</span><span class="p">)</span>
        <span class="n">nFolds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOrDefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numFolds</span><span class="p">)</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOrDefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Getting Label and altEvaluators</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLabel</span><span class="p">()</span>
        <span class="n">altEvaluators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAltEvaluators</span><span class="p">()</span>
        <span class="n">altMetrics</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">altEvaluators</span><span class="p">)]</span> <span class="o">*</span> <span class="n">numModels</span> <span class="k">if</span> <span class="n">altEvaluators</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nFolds</span>
        <span class="n">randCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span> <span class="o">+</span> <span class="s2">&quot;_rand&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">randCol</span><span class="p">))</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numModels</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getParallelism</span><span class="p">(),</span> <span class="n">numModels</span><span class="p">))</span>
        <span class="n">subModels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">collectSubModelsParam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCollectSubModels</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">collectSubModelsParam</span><span class="p">:</span>
            <span class="n">subModels</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numModels</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nFolds</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nFolds</span><span class="p">):</span>
            <span class="c1"># Getting the splits such that no data is reused</span>
            <span class="n">validateLB</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">validateUB</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">randCol</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">validateLB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">randCol</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">validateUB</span><span class="p">)</span>
            <span class="n">validation</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
            <span class="n">train</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>

            <span class="c1"># Oversampling the minority class(s) here</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toOverSample</span><span class="p">:</span>
                <span class="n">withReplacement</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">oversampler</span> <span class="o">=</span> <span class="n">OverSampler</span><span class="p">(</span><span class="n">labelCol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>

                <span class="c1"># Oversampling</span>
                <span class="n">train</span> <span class="o">=</span> <span class="n">oversampler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">train</span><span class="p">)</span>
            <span class="c1"># Getting the individual tasks so this can be parallelized</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallelFitTasks</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">eva</span><span class="p">,</span> <span class="n">validation</span><span class="p">,</span> <span class="n">epm</span><span class="p">,</span> <span class="n">collectSubModelsParam</span><span class="p">,</span> <span class="n">altEvaluators</span><span class="p">)</span>
            <span class="c1"># Calling the parallel process</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">fold_alt_metrics</span><span class="p">,</span> <span class="n">subModel</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">(),</span> <span class="n">tasks</span><span class="p">):</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">metric</span> <span class="o">/</span> <span class="n">nFolds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fold_alt_metrics</span><span class="p">:</span>
                    <span class="n">altMetrics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">altMetrics</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">fold_alt_metrics</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">nFolds</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">altEvaluators</span><span class="p">))]</span>

                <span class="k">if</span> <span class="n">collectSubModelsParam</span><span class="p">:</span>
                    <span class="n">subModels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">subModel</span>

            <span class="n">validation</span><span class="o">.</span><span class="n">unpersist</span><span class="p">()</span>
            <span class="n">train</span><span class="o">.</span><span class="n">unpersist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">eva</span><span class="o">.</span><span class="n">isLargerBetter</span><span class="p">():</span>
            <span class="n">bestIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bestIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="n">bestModel</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epm</span><span class="p">[</span><span class="n">bestIndex</span><span class="p">])</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">[(</span><span class="n">metric</span><span class="p">,</span> <span class="n">altMetrics</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">metric</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metrics</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copyValues</span><span class="p">(</span><span class="n">CrossValidatorModel</span><span class="p">(</span><span class="n">bestModel</span><span class="p">,</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">subModels</span><span class="p">))</span></div>


<span class="c1">## Pipeline Functions</span>
<div class="viewcode-block" id="get_string_pipeline"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.get_string_pipeline">[docs]</a><span class="k">def</span> <span class="nf">get_string_pipeline</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols_to_exclude</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;StringIndexer&#39;</span><span class="p">,</span> <span class="s1">&#39;OneHotEncoder&#39;</span><span class="p">,</span> <span class="s1">&#39;OneHotDummies&#39;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list of preprocessing stages</span>
<span class="sd">    </span>
<span class="sd">    :param df: DataFrame including only the training data</span>
<span class="sd">    :param cols_to_exclude: Column names we don&#39;t want to to include in the preprocessing (i.e. SUBJECT/ target column)</span>
<span class="sd">    :param stages: preprocessing steps to take</span>
<span class="sd">    :return:  (stages, Numeric_Columns)</span>
<span class="sd">        stages: list of pipeline stages to be used in preprocessing</span>
<span class="sd">        Numeric_Columns: list of columns that contain numeric features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">String_Columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Numeric_Columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_type</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>  <span class="c1"># This is a tuple of (&lt;col name&gt;, data type)</span>
        <span class="k">if</span> <span class="n">_col</span> <span class="ow">in</span> <span class="n">cols_to_exclude</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="n">String_Columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;double&#39;</span> <span class="ow">or</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span> <span class="ow">or</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
            <span class="n">Numeric_Columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unhandled Data type = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">_col</span><span class="p">,</span> <span class="n">_type</span><span class="p">)))</span>
            <span class="k">continue</span>

    <span class="n">stages</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="s1">&#39;StringIndexer&#39;</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="c1"># String Inexing</span>
        <span class="n">str_indexers</span> <span class="o">=</span> <span class="p">[</span><span class="n">StringIndexer</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_ind&#39;</span><span class="p">,</span> <span class="n">handleInvalid</span><span class="o">=</span><span class="s1">&#39;skip&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
        <span class="n">indexed_string_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_ind&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="n">stages</span> <span class="o">+</span> <span class="n">str_indexers</span>

    <span class="k">if</span> <span class="s1">&#39;OneHotEncoder&#39;</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="c1"># One hot encoding</span>
        <span class="n">str_hot</span> <span class="o">=</span> <span class="p">[</span><span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_ind&#39;</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_vec&#39;</span><span class="p">,</span> <span class="n">dropLast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
        <span class="n">encoded_str_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_vec&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="n">stages</span> <span class="o">+</span> <span class="n">str_hot</span>

    <span class="k">if</span> <span class="s1">&#39;OneHotDummies&#39;</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="c1"># Converting the sparse vector to dummy columns</span>
        <span class="n">str_dumbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">OneHotDummies</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_vec&#39;</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s1">&#39;_dummy&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
        <span class="n">str_dumb_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="n">str_dumbers</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dummy</span><span class="o">.</span><span class="n">getOutCols</span><span class="p">()]</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="n">stages</span> <span class="o">+</span> <span class="n">str_dumbers</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ERROR</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Parameter &lt;steps&gt; must include &#39;StringIndexer&#39;, &#39;OneHotEncoder&#39;, &#39;OneHotDummies&#39;</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stages</span><span class="p">,</span> <span class="n">Numeric_Columns</span></div>


<div class="viewcode-block" id="vector_assembler_pipeline"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.vector_assembler_pipeline">[docs]</a><span class="k">def</span> <span class="nf">vector_assembler_pipeline</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">doPCA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    After preprocessing String Columns, this function can be used to assemble a feature vector to be used for learning</span>
<span class="sd">    creates the following stages: VectorAssembler -&gt; Standard Scalar [{ -&gt; PCA}]</span>
<span class="sd">    </span>
<span class="sd">    :param df: DataFrame containing preprocessed Columns</span>
<span class="sd">    :param columns: list of Column names of the preprocessed columns</span>
<span class="sd">    :param doPCA:  Do you want to do PCA as part of the vector assembler? defaults to False</span>
<span class="sd">    :param k:  Number of Principal Components to use, defaults to 10</span>
<span class="sd">    :return: List of vector assembling stages</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">assembler</span> <span class="o">=</span> <span class="n">VectorAssembler</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s1">&#39;featuresVec&#39;</span><span class="p">)</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="s2">&quot;featuresVec&quot;</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;features&quot;</span><span class="p">,</span> <span class="n">withStd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">withMean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># centering and standardizing the data</span>

    <span class="k">if</span> <span class="n">doPCA</span><span class="p">:</span>
        <span class="n">pca_obj</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="s2">&quot;features&quot;</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;pcaFeatures&quot;</span><span class="p">)</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="n">assembler</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">pca_obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="n">assembler</span><span class="p">,</span> <span class="n">scaler</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">stages</span></div>


<div class="viewcode-block" id="postprocessing_pipeline"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.postprocessing_pipeline">[docs]</a><span class="k">def</span> <span class="nf">postprocessing_pipeline</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols_to_exclude</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assemble postprocessing pipeline to reconstruct original categorical indexed values from OneHotDummy Columns</span>
<span class="sd">    </span>
<span class="sd">    :param df: DataFrame Including the original string Columns</span>
<span class="sd">    :param cols_to_exclude: list of columns to exclude</span>
<span class="sd">    :return: (reconstructers, String_Columns)</span>
<span class="sd">        reconstructers: list of IndReconstructer stages</span>
<span class="sd">        String_Columns: list of columns that are being reconstructed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">String_Columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Numeric_Columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_col</span><span class="p">,</span> <span class="n">_type</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>  <span class="c1"># This is a tuple of (&lt;col name&gt;, data type)</span>
        <span class="k">if</span> <span class="n">_col</span> <span class="ow">in</span> <span class="n">cols_to_exclude</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="n">String_Columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;double&#39;</span> <span class="ow">or</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span> <span class="ow">or</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
            <span class="n">Numeric_Columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unhandled Data type = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">_col</span><span class="p">,</span> <span class="n">_type</span><span class="p">)))</span>
            <span class="k">continue</span>

    <span class="c1"># Extracting the Value of the OneHotEncoded Variable</span>
    <span class="n">reconstructors</span> <span class="o">=</span> <span class="p">[</span><span class="n">IndReconstructer</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_activeInd&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">reconstructors</span><span class="p">,</span> <span class="n">String_Columns</span></div>


<span class="c1"># Distribution fitting Functions</span>
<div class="viewcode-block" id="make_pdf"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.make_pdf">[docs]</a><span class="k">def</span> <span class="nf">make_pdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate distributions&#39;s Probability Distribution Function</span>
<span class="sd">    </span>
<span class="sd">    :param dist: scipy.stats distribution object: https://docs.scipy.org/doc/scipy/reference/stats.html</span>
<span class="sd">    :param params: distribution parameters</span>
<span class="sd">    :param size: how many data points to generate , defaults to 10000</span>
<span class="sd">    :return: series of probability density function for this distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Separate parts of parameters</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Get sane start and end points of distribution</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span> <span class="k">if</span> <span class="n">arg</span> <span class="k">else</span> <span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span> <span class="k">if</span> <span class="n">arg</span> <span class="k">else</span> <span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

    <span class="c1"># Build PDF and turn into pandas Series</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pdf</span></div>


<div class="viewcode-block" id="best_fit_distribution"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.best_fit_distribution">[docs]</a><span class="k">def</span> <span class="nf">best_fit_distribution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Model data by finding best fit distribution to data</span>
<span class="sd">    </span>
<span class="sd">    :param data: DataFrame with one column containing the feature whose distribution is to be investigated</span>
<span class="sd">    :param col_name: column name for feature</span>
<span class="sd">    :param bins: number of bins to use in generating the histogram of this data</span>
<span class="sd">    :param ax: axis to plot histogram on</span>
<span class="sd">    :return: (best_distribution.name, best_params, best_sse)</span>
<span class="sd">        best_distribution.name: string of the best distribution name</span>
<span class="sd">        best_params: parameters for this distribution</span>
<span class="sd">        best_sse: sum of squared errors for this distribution against the empirical pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get histogram of original data</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">dist_explore</span><span class="o">.</span><span class="n">pandas_histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)]))</span>
    <span class="n">output</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span>
    <span class="c1"># DISTRIBUTIONS = [</span>
    <span class="c1">#     st.alpha,st.anglit,st.arcsine,st.beta,st.betaprime,st.bradford,st.burr,st.cauchy,st.chi,st.chi2,st.cosine,</span>
    <span class="c1">#     st.dgamma,st.dweibull,st.erlang,st.expon,st.exponnorm,st.exponweib,st.exponpow,st.f,st.fatiguelife,st.fisk,</span>
    <span class="c1">#     st.foldcauchy,st.foldnorm,st.frechet_r,st.frechet_l,st.genlogistic,st.genpareto,st.gennorm,st.genexpon,</span>
    <span class="c1">#     st.genextreme,st.gausshyper,st.gamma,st.gengamma,st.genhalflogistic,st.gilbrat,st.gompertz,st.gumbel_r,</span>
    <span class="c1">#     st.gumbel_l,st.halfcauchy,st.halflogistic,st.halfnorm,st.halfgennorm,st.hypsecant,st.invgamma,st.invgauss,</span>
    <span class="c1">#     st.invweibull,st.johnsonsb,st.johnsonsu,st.ksone,st.kstwobign,st.laplace,st.levy,st.levy_l,st.levy_stable,</span>
    <span class="c1">#     st.logistic,st.loggamma,st.loglaplace,st.lognorm,st.lomax,st.maxwell,st.mielke,st.nakagami,st.ncx2,st.ncf,</span>
    <span class="c1">#     st.nct,st.norm,st.pareto,st.pearson3,st.powerlaw,st.powerlognorm,st.powernorm,st.rdist,st.reciprocal,</span>
    <span class="c1">#     st.rayleigh,st.rice,st.recipinvgauss,st.semicircular,st.t,st.triang,st.truncexpon,st.truncnorm,st.tukeylambda,</span>
    <span class="c1">#     st.uniform,st.vonmises,st.vonmises_line,st.wald,st.weibull_min,st.weibull_max,st.wrapcauchy</span>
    <span class="c1"># ]</span>

    <span class="n">DISTRIBUTIONS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">st</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">expon</span><span class="p">,</span>
        <span class="n">st</span><span class="o">.</span><span class="n">halfnorm</span><span class="p">,</span>
        <span class="n">st</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">st</span><span class="o">.</span><span class="n">lognorm</span><span class="p">,</span>
        <span class="n">st</span><span class="o">.</span><span class="n">uniform</span>
    <span class="p">]</span>

    <span class="c1"># Best holders</span>
    <span class="n">best_distribution</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">norm</span>
    <span class="n">best_params</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">best_sse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># Estimate distribution parameters from data</span>
    <span class="k">for</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">DISTRIBUTIONS</span><span class="p">):</span>

        <span class="c1"># Try to fit the distribution</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Ignore warnings from data that can&#39;t be fit</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

                <span class="c1"># fit dist to data</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>

                <span class="c1"># Separate parts of parameters</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Calculate fitted PDF and error with fit in distribution</span>

                <span class="n">pdf</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">sse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>

                <span class="c1"># if axis pass in add to plot</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ax</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sse</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                            <span class="c1"># Don&#39;t want to plot really bad ones</span>
                            <span class="n">ax</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">distribution</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                            <span class="c1"># ax.plot(x,pdf, label = distribution.name)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="c1"># identify if this distribution is better</span>
                <span class="k">if</span> <span class="n">best_sse</span> <span class="o">&gt;</span> <span class="n">sse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_distribution</span> <span class="o">=</span> <span class="n">distribution</span>
                    <span class="n">best_params</span> <span class="o">=</span> <span class="n">params</span>
                    <span class="n">best_sse</span> <span class="o">=</span> <span class="n">sse</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">best_distribution</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">best_params</span><span class="p">,</span> <span class="n">best_sse</span><span class="p">)</span></div>


<span class="c1">## PCA Functions</span>

<div class="viewcode-block" id="estimateCovariance"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.estimateCovariance">[docs]</a><span class="k">def</span> <span class="nf">estimateCovariance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">features_col</span><span class="o">=</span><span class="s1">&#39;features&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the covariance matrix for a given dataframe.</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    :param df: PySpark dataframe</span>
<span class="sd">    :param features_col: name of the column with the features, defaults to &#39;features&#39;</span>
<span class="sd">    :return: np.ndarray: A multi-dimensional array where the number of rows and columns both equal the length of the arrays in the input dataframe.</span>

<span class="sd">    :Note: </span>
<span class="sd">        The multi-dimensional covariance array should be calculated using outer products.  Don&#39;t forget to normalize the data by first subtracting the mean.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">features_col</span><span class="p">])</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">dfZeroMean</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">features_col</span><span class="p">])</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>  <span class="c1"># subtract the mean</span>

    <span class="k">return</span> <span class="n">dfZeroMean</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></div>


<div class="viewcode-block" id="pca_with_scores"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.pca_with_scores">[docs]</a><span class="k">def</span> <span class="nf">pca_with_scores</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the top `k` principal components, corresponding scores, and all eigenvalues.</span>

<span class="sd">    :param df:  A Spark dataframe with a &#39;features&#39; column, which (column) consists of DenseVectors.</span>
<span class="sd">    :param k: The number of principal components to return., defaults to 10</span>
<span class="sd">    :return: (eigenvectors, `RDD` of scores, eigenvalues)\n</span>
<span class="sd">        * Eigenvectors: multi-dimensional array where the number of\</span>
<span class="sd">            rows equals the length of the arrays in the input `RDD` and the number of columns equals`k`.</span>
<span class="sd">        * `RDD` of scores: has the same number of rows as `data` and consists of arrays of length `k`.</span>
<span class="sd">        * Eigenvalues is an array of length d (the number of features).</span>
<span class="sd">    </span>
<span class="sd">    :Note:</span>
<span class="sd">        All eigenvalues should be returned in sorted order (largest to smallest). `eigh` returns</span>
<span class="sd">        each eigenvectors as a column.  This function should also return eigenvectors as columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">estimateCovariance</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">eigVals</span><span class="p">,</span> <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigVals</span><span class="p">)</span>
    <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">eigVecs</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">eigVecs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span>
    <span class="n">eigVals</span> <span class="o">=</span> <span class="n">eigVals</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># sort eigenvals</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="c1"># Return the `k` principal components, `k` scores, and all eigenvalues</span>

    <span class="k">return</span> <span class="n">components</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">eigVals</span></div>


<div class="viewcode-block" id="varianceExplained"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.varianceExplained">[docs]</a><span class="k">def</span> <span class="nf">varianceExplained</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the proportion of variance explained by `k` principal componenets. Calls the above PCA procedure</span>
<span class="sd">    </span>
<span class="sd">    :param df: PySpark DataFrame</span>
<span class="sd">    :param k: number of principal components , defaults to 10</span>
<span class="sd">    :return: (proportion, principal_components, scores, eigenvalues)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">components</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">pca_with_scores</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">),</span> <span class="n">components</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">eigenvalues</span></div>


<span class="c1"># PCA reconstruction Functions</span>

<div class="viewcode-block" id="reconstructPCA"><a class="viewcode-back" href="../../splicemachine.stats.html#splicemachine.stats.reconstructPCA">[docs]</a><span class="k">def</span> <span class="nf">reconstructPCA</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">originalColumns</span><span class="p">,</span> <span class="n">fits</span><span class="p">,</span> <span class="n">pcaColumn</span><span class="o">=</span><span class="s1">&#39;pcaFeatures&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct data from lower dimensional space after performing PCA</span>
<span class="sd">    </span>
<span class="sd">    :param sql: SQLContext</span>
<span class="sd">    :param df: PySpark DataFrame: inputted PySpark DataFrame</span>
<span class="sd">    :param pc: numpy.ndarray: principal components projected onto</span>
<span class="sd">    :param mean: numpy.ndarray: mean of original columns</span>
<span class="sd">    :param std: numpy.ndarray: standard deviation of original columns</span>
<span class="sd">    :param originalColumns: list: original column names</span>
<span class="sd">    :param fits: fits of features returned from best_fit_distribution</span>
<span class="sd">    :param pcaColumn: column in df that contains PCA features, defaults to &#39;pcaFeatures&#39;</span>
<span class="sd">    :return: dataframe containing reconstructed data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">cols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pcaColumn</span><span class="p">)</span>

    <span class="n">pddf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">toPandas</span><span class="p">()</span>
    <span class="n">first_series</span> <span class="o">=</span> <span class="n">pddf</span><span class="p">[</span><span class="s1">&#39;pcaFeatures&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">toArray</span><span class="p">()))</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">first_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first_series</span><span class="p">)</span>
    <span class="c1"># undo-ing PCA</span>
    <span class="n">first_reconstructed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">first_features</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
    <span class="c1"># undo-ing the scaling</span>
    <span class="n">first_reconstructed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">first_reconstructed</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean</span>
    <span class="n">first_reconstructedDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">first_reconstructed</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">originalColumns</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
        <span class="n">first_reconstructedDF</span><span class="p">[</span><span class="n">_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pddf</span><span class="p">[</span><span class="n">_col</span><span class="p">]</span>

    <span class="c1"># This is a pyspark Dataframe containing the reconstructed data, including the dummy columns for the string variables-- next step is to reverse the one-hot-encoding for the string columns</span>
    <span class="n">first_reconstructed</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">first_reconstructedDF</span><span class="p">)</span>

    <span class="n">cols_to_exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DATE_OF_STUDY&#39;</span><span class="p">]</span>
    <span class="n">postPipeStages</span><span class="p">,</span> <span class="n">String_Columns</span> <span class="o">=</span> <span class="n">postprocessing_pipeline</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols_to_exclude</span><span class="p">)</span>

    <span class="n">postPipe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">stages</span><span class="o">=</span><span class="n">postPipeStages</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">postPipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">first_reconstructed</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">first_reconstructed</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_col</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">_col</span><span class="p">,</span> <span class="n">_col</span> <span class="o">+</span> <span class="s1">&#39;_ind&#39;</span><span class="p">])</span> \
                       <span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">_col</span> <span class="o">+</span> <span class="s1">&#39;_ind&#39;</span><span class="p">,</span> <span class="n">_col</span> <span class="o">+</span> <span class="s1">&#39;_activeInd&#39;</span><span class="p">),</span> <span class="n">_col</span> <span class="o">+</span> <span class="s1">&#39;_activeInd&#39;</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">dropDuplicates</span><span class="p">()</span>
    <span class="n">cols_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">_col</span> <span class="k">for</span> <span class="n">_col</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">base</span> <span class="ow">in</span> <span class="n">_col</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">String_Columns</span><span class="p">])</span> <span class="ow">and</span> <span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">_col</span><span class="p">]</span>

    <span class="n">reconstructedDF</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="o">*</span><span class="n">cols_to_drop</span><span class="p">)</span>  <span class="c1"># This is the equivalent as the first translated reconstructed dataframe above</span>
    <span class="n">clip</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">DoubleType</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">fits</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">fits</span><span class="p">[</span><span class="n">_key</span><span class="p">][</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;EMPIRICAL&#39;</span><span class="p">:</span>
            <span class="n">reconstructedDF</span> <span class="o">=</span> <span class="n">reconstructedDF</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">_key</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reconstructedDF</span> <span class="o">=</span> <span class="n">reconstructedDF</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">clip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">_key</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">reconstructedDF</span></div>


<span class="k">class</span> <span class="nc">MarkovChain</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the MarkovChain instance.</span>

<span class="sd">        :param: transition_prob: dict\</span>
<span class="sd">            A dict object representing the transition\</span>
<span class="sd">            probabilities in Markov Chain.\</span>
<span class="sd">            Should be of the form:\</span>
<span class="sd">                {&#39;state1&#39;: {&#39;state1&#39;: 0.1, &#39;state2&#39;: 0.4},</span>
<span class="sd">                 &#39;state2&#39;: {...}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="n">transition_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">transition_prob</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># states that have transitions to the next layer</span>
        <span class="c1"># For states in the form &lt;stateN_M&gt; where N is the visit (layer) and M is the cluster in the N-th Layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_max_num_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span>

    <span class="k">def</span> <span class="nf">next_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the state of the random variable at the next time</span>
<span class="sd">        instance.</span>
<span class="sd">        </span>
<span class="sd">        :param current_state: The current state of the system.</span>
<span class="sd">        :raises: Exception if random choice fails</span>
<span class="sd">        :return: next state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="c1"># if not current_state in self.states:</span>
            <span class="c1">#     print(&#39;We have reached node {} where we do not know where they go from here... \n try reducing the number of clusters at level {} \n otherwise we might be at the terminating layer&#39;.format(current_state, int(current_state.split(&#39;state&#39;)[1][0])))</span>
            <span class="c1">#     raise Exception(&#39;Unknown transition&#39;)</span>

            <span class="n">next_possible_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[</span><span class="n">current_state</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="n">next_possible_states</span><span class="p">,</span>
                <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[</span><span class="n">current_state</span><span class="p">][</span><span class="n">next_state</span><span class="p">]</span>
                   <span class="k">for</span> <span class="n">next_state</span> <span class="ow">in</span> <span class="n">next_possible_states</span><span class="p">]</span>
            <span class="p">)[:]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">generate_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">no</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the next states of the system.</span>

<span class="sd">        :param current_state: (str) The state of the current random variable.</span>
<span class="sd">        :param no: (int) The number of future states to generate.</span>
<span class="sd">        :param last: (bool) Do we want to return just the last value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of steps exceeds the max number of possible next steps&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;&lt;no&gt; should not exceed </span><span class="si">{}</span><span class="s1">. The value of &lt;no&gt; was: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span><span class="p">,</span> <span class="n">no</span><span class="p">))</span>

            <span class="n">future_states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_state</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="n">future_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>
                <span class="n">current_state</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">future_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">future_states</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">rep_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">no</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_reps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Running generate states a bunch of times and returning the final state that happens the most</span>

<span class="sd">        :param current_state: (str) The state of the current random variable</span>
<span class="sd">        :param no: (int) number of time steps in the future to run</span>
<span class="sd">        num_reps int number of times to run the simpca_with_scoresultion forward</span>
<span class="sd">        :return state: the most commonly reached state at the end of these runs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">no</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of steps exceeds the max number of possible next steps&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;&lt;no&gt; should not exceed </span><span class="si">{}</span><span class="s1">. The value of &lt;no&gt; was: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_steps</span><span class="p">,</span> <span class="n">no</span><span class="p">))</span>

        <span class="n">endstates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_reps</span><span class="p">):</span>
            <span class="n">endstates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_states</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">no</span><span class="o">=</span><span class="n">no</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">endstates</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">endstates</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Splice Machine

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>